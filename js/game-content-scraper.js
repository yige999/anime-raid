/**
 * Game Content Scraper - Ê∏∏ÊàèÂÜÖÂÆπËá™Âä®ÊäìÂèñÁ≥ªÁªü
 * Ëá™Âä®‰ªéÂÆòÊñπÁ§æ‰∫§Â™í‰Ωì„ÄÅÁΩëÁ´ôÁ≠âÊ∏†ÈÅìÊäìÂèñÊúÄÊñ∞ÂÖëÊç¢Á†ÅÂíåÊ∏∏Êàè‰ø°ÊÅØ
 *
 * ÈáçË¶ÅÊèêÁ§∫Ôºö
 * 1. ËØ∑ÈÅµÂÆàÂêÑÂπ≥Âè∞ÁöÑrobots.txtÂíå‰ΩøÁî®Êù°Ê¨æ
 * 2. ÂêàÁêÜËÆæÁΩÆÊäìÂèñÈ¢ëÁéáÔºåÈÅøÂÖçÂØπÂÆòÊñπÊúçÂä°Âô®ÈÄ†ÊàêÂéãÂäõ
 * 3. ‰ªÖÊäìÂèñÂÖ¨ÂºÄ‰ø°ÊÅØÔºåÂ∞äÈáçÁâàÊùÉ
 * 4. Âª∫ËÆÆËÅîÁ≥ªÂÆòÊñπËé∑ÂæóAPIÊéàÊùÉ
 */

class GameContentScraper {
    constructor() {
        this.sources = {
            twitter: {
                enabled: true,
                lastCheck: null,
                interval: 1800000, // 30ÂàÜÈíü
                keywords: ['anime raid code', 'animeraid', 'anime raid gift']
            },
            discord: {
                enabled: true,
                lastCheck: null,
                interval: 1800000, // 30ÂàÜÈíü
                channels: ['announcements', 'updates', 'gift-codes']
            },
            officialWebsite: {
                enabled: true,
                lastCheck: null,
                interval: 3600000, // 1Â∞èÊó∂
                urls: [
                    'https://animeraidgame.com/news',
                    'https://animeraidgame.com/events',
                    'https://animeraidgame.com/codes'
                ]
            },
            reddit: {
                enabled: true,
                lastCheck: null,
                interval: 3600000, // 1Â∞èÊó∂
                subreddits: ['AnimeRaid', 'animeraid']
            }
        };

        this.scrapedData = new Map();
        this.cacheManager = new ScrapedDataCache();
        this.rateLimiter = new RateLimiter();
        this.contentValidator = new ContentValidator();

        this.init();
    }

    /**
     * ÂàùÂßãÂåñÊäìÂèñÂô®
     */
    init() {
        this.loadStoredData();
        this.startPeriodicScraping();
        this.setupEventHandlers();
        console.log('Game Content Scraper initialized');
    }

    /**
     * ÂêØÂä®ÂÆöÊúüÊäìÂèñ
     */
    startPeriodicScraping() {
        // ÊØè5ÂàÜÈíüÊ£ÄÊü•‰∏ÄÊ¨°ÊòØÂê¶ÈúÄË¶ÅÊäìÂèñ
        setInterval(() => {
            this.performScheduledScraping();
        }, 300000);

        // ÂêØÂä®Êó∂Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°
        setTimeout(() => {
            this.performScheduledScraping();
        }, 5000);
    }

    /**
     * ÊâßË°åËÆ°ÂàíÊäìÂèñ
     */
    async performScheduledScraping() {
        const now = Date.now();

        // Ê£ÄÊü•ÊØè‰∏™Êï∞ÊçÆÊ∫ê
        for (const [source, config] of Object.entries(this.sources)) {
            if (!config.enabled) continue;

            if (this.shouldScrape(source, config, now)) {
                try {
                    await this.scrapeSource(source);
                    config.lastCheck = now;
                } catch (error) {
                    console.error(`Failed to scrape ${source}:`, error);
                    this.handleScrapingError(source, error);
                }
            }
        }
    }

    /**
     * Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•ÊäìÂèñ
     */
    shouldScrape(source, config, now) {
        if (!config.lastCheck) return true;
        return (now - config.lastCheck) >= config.interval;
    }

    /**
     * ÊäìÂèñÊåáÂÆöÊï∞ÊçÆÊ∫ê
     */
    async scrapeSource(source) {
        console.log(`Starting to scrape ${source}...`);

        switch (source) {
            case 'twitter':
                await this.scrapeTwitter();
                break;
            case 'discord':
                await this.scrapeDiscord();
                break;
            case 'officialWebsite':
                await this.scrapeOfficialWebsite();
                break;
            case 'reddit':
                await this.scrapeReddit();
                break;
        }
    }

    /**
     * ÊäìÂèñTwitterÂÜÖÂÆπ
     * Ê≥®ÊÑèÔºöÁî±‰∫éTwitter APIÈôêÂà∂ÔºåËøôÈáå‰ΩøÁî®‰ª£ÁêÜÊñπÊ°à
     */
    async scrapeTwitter() {
        const config = this.sources.twitter;

        try {
            // ÊñπÊ°à1Ôºö‰ΩøÁî®Twitter API v2ÔºàÈúÄË¶ÅAPIÂØÜÈí•Ôºâ
            // const tweets = await this.fetchTwitterAPI(config.keywords);

            // ÊñπÊ°à2Ôºö‰ΩøÁî®NitterÂÆû‰æãÔºàÂºÄÊ∫êTwitterÂâçÁ´ØÔºâ
            const tweets = await this.fetchFromNitter(config.keywords);

            const newCodes = this.extractCodesFromTweets(tweets);
            await this.processScrapedCodes('twitter', newCodes);

        } catch (error) {
            console.error('Twitter scraping failed:', error);
            throw error;
        }
    }

    /**
     * ‰ªéNitterÂÆû‰æãËé∑ÂèñTwitterÂÜÖÂÆπ
     */
    async fetchFromNitter(keywords) {
        const nitterInstance = 'https://nitter.net'; // ÂèØ‰ª•‰ΩøÁî®ÂÖ∂‰ªñÂÆû‰æã
        const searchUrl = `${nitterInstance}/search?q=${encodeURIComponent(keywords.join(' OR '))}&f=tweets`;

        try {
            // ‰ΩøÁî®CORS‰ª£ÁêÜÊàñÂêéÁ´ØAPI
            const response = await this.fetchWithProxy(searchUrl);
            const html = await response.text();
            return this.parseTweetsFromHTML(html);
        } catch (error) {
            console.error('Nitter fetch failed:', error);
            return [];
        }
    }

    /**
     * ‰ªéHTMLËß£ÊûêÊé®ÊñáÂÜÖÂÆπ
     */
    parseTweetsFromHTML(html) {
        const tweets = [];
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Êü•ÊâæÊé®ÊñáÂÖÉÁ¥†
        const tweetElements = doc.querySelectorAll('.timeline-item');

        tweetElements.forEach(element => {
            const tweet = {
                id: this.extractTweetId(element),
                content: this.extractTweetContent(element),
                author: this.extractTweetAuthor(element),
                timestamp: this.extractTweetTimestamp(element),
                url: this.extractTweetUrl(element)
            };

            if (tweet.content && tweet.author) {
                tweets.push(tweet);
            }
        });

        return tweets;
    }

    /**
     * ÊäìÂèñDiscordÂÜÖÂÆπ
     * Ê≥®ÊÑèÔºöÈúÄË¶ÅDiscord Bot‰ª§ÁâåÊàñWebhook
     */
    async scrapeDiscord() {
        const config = this.sources.discord;

        try {
            // ÊñπÊ°à1Ôºö‰ΩøÁî®Discord Bot API
            // const messages = await this.fetchDiscordMessages(config.channels);

            // ÊñπÊ°à2ÔºöÁõëÊéßÂÖ¨ÂºÄÁöÑDiscord Webhook
            const announcements = await this.fetchDiscordAnnouncements();

            const newCodes = this.extractCodesFromDiscord(announcements);
            await this.processScrapedCodes('discord', newCodes);

        } catch (error) {
            console.error('Discord scraping failed:', error);
            throw error;
        }
    }

    /**
     * Ëé∑ÂèñDiscordÂÖ¨Âëä
     */
    async fetchDiscordAnnouncements() {
        // ËøôÈáåÈúÄË¶ÅÊ†πÊçÆÂÆûÈôÖÁöÑDiscordÊúçÂä°Âô®ÈÖçÁΩÆ
        // ÂèØ‰ª•‰ΩøÁî®Discord.jsÂ∫ìÊàñDiscord API

        // Ê®°ÊãüÂÆûÁé∞
        return [
            {
                id: 'mock_announcement_1',
                content: 'üéâ New gift code: GAME2025 - Valid until next week!',
                author: 'Official Bot',
                timestamp: new Date().toISOString(),
                channel: 'announcements'
            }
        ];
    }

    /**
     * ÊäìÂèñÂÆòÊñπÁΩëÁ´ô
     */
    async scrapeOfficialWebsite() {
        const config = this.sources.officialWebsite;
        const allCodes = [];

        for (const url of config.urls) {
            try {
                const response = await this.fetchWithProxy(url);
                const html = await response.text();
                const codes = this.extractCodesFromWebsite(html, url);
                allCodes.push(...codes);

                // ËØ∑Ê±ÇÈó¥ÈöîÔºåÈÅøÂÖçËøá‰∫éÈ¢ëÁπÅ
                await this.rateLimiter.wait();
            } catch (error) {
                console.error(`Failed to scrape ${url}:`, error);
            }
        }

        await this.processScrapedCodes('website', allCodes);
    }

    /**
     * ‰ªéÁΩëÁ´ôHTMLÊèêÂèñÂÖëÊç¢Á†Å
     */
    extractCodesFromWebsite(html, sourceUrl) {
        const codes = [];
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Êü•ÊâæÂèØËÉΩÁöÑÂÖëÊç¢Á†ÅÂÖÉÁ¥†
        const codeElements = doc.querySelectorAll([
            '.code-box',
            '.gift-code',
            '.promo-code',
            '[class*="code"]',
            '[class*="promo"]'
        ].join(','));

        codeElements.forEach(element => {
            const code = this.extractCodeFromElement(element);
            if (code) {
                codes.push({
                    ...code,
                    source: 'website',
                    sourceUrl: sourceUrl,
                    foundAt: new Date().toISOString()
                });
            }
        });

        // Âú®ÊñáÊú¨‰∏≠ÊêúÁ¥¢ÂÖëÊç¢Á†ÅÊ®°Âºè
        const textContent = doc.body.textContent || '';
        const textCodes = this.extractCodesFromText(textContent);
        textCodes.forEach(code => {
            codes.push({
                code: code.code,
                description: code.description,
                source: 'website',
                sourceUrl: sourceUrl,
                foundAt: new Date().toISOString(),
                confidence: code.confidence
            });
        });

        return codes;
    }

    /**
     * ÊäìÂèñRedditÂÜÖÂÆπ
     */
    async scrapeReddit() {
        const config = this.sources.reddit;
        const allCodes = [];

        for (const subreddit of config.subreddits) {
            try {
                const url = `https://www.reddit.com/r/${subreddit}/search.json?q=code+OR+gift+OR+promo&sort=new&limit=25`;
                const response = await this.fetchWithProxy(url);
                const data = await response.json();

                const codes = this.extractCodesFromReddit(data.data.children);
                allCodes.push(...codes);

                await this.rateLimiter.wait();
            } catch (error) {
                console.error(`Failed to scrape r/${subreddit}:`, error);
            }
        }

        await this.processScrapedCodes('reddit', allCodes);
    }

    /**
     * ‰ªéRedditÊï∞ÊçÆÊèêÂèñÂÖëÊç¢Á†Å
     */
    extractCodesFromReddit(posts) {
        const codes = [];

        posts.forEach(post => {
            const postData = post.data;
            const textCodes = this.extractCodesFromText(`${postData.title} ${postData.selftext}`);

            textCodes.forEach(code => {
                codes.push({
                    ...code,
                    source: 'reddit',
                    sourceUrl: `https://reddit.com${postData.permalink}`,
                    author: postData.author,
                    subreddit: postData.subreddit,
                    foundAt: new Date(postData.created_utc * 1000).toISOString()
                });
            });
        });

        return codes;
    }

    /**
     * ‰ªéÊé®ÊñáÂÜÖÂÆπÊèêÂèñÂÖëÊç¢Á†Å
     */
    extractCodesFromTweets(tweets) {
        const codes = [];

        tweets.forEach(tweet => {
            const textCodes = this.extractCodesFromText(tweet.content);
            textCodes.forEach(code => {
                codes.push({
                    ...code,
                    source: 'twitter',
                    sourceUrl: tweet.url,
                    author: tweet.author,
                    foundAt: tweet.timestamp
                });
            });
        });

        return codes;
    }

    /**
     * ‰ªéDiscordÊ∂àÊÅØÊèêÂèñÂÖëÊç¢Á†Å
     */
    extractCodesFromDiscord(messages) {
        const codes = [];

        messages.forEach(message => {
            const textCodes = this.extractCodesFromText(message.content);
            textCodes.forEach(code => {
                codes.push({
                    ...code,
                    source: 'discord',
                    sourceUrl: `discord://channels/${message.channel}/${message.id}`,
                    author: message.author,
                    channel: message.channel,
                    foundAt: message.timestamp
                });
            });
        });

        return codes;
    }

    /**
     * ‰ªéÊñáÊú¨‰∏≠ÊèêÂèñÂÖëÊç¢Á†Å
     * ‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÂåπÈÖçÂ∏∏ËßÅÁöÑÂÖëÊç¢Á†ÅÊ†ºÂºè
     */
    extractCodesFromText(text) {
        const codes = [];

        // ÂÖëÊç¢Á†ÅÊ®°ÂºèÔºàÂ§ßÂÜôÂ≠óÊØçÂíåÊï∞Â≠óÔºåÈÄöÂ∏∏8-20‰∏™Â≠óÁ¨¶Ôºâ
        const codePatterns = [
            /\b([A-Z0-9]{8,20})\b/g, // Âü∫Á°ÄÊ®°Âºè
            /\b(GIFT|CODE|PROMO)[-_]?([A-Z0-9]{6,16})\b/gi, // Â∏¶ÂâçÁºÄ
            /\b([A-Z]{3,}[-_]?[0-9]{3,})\b/g, // Â≠óÊØçÊï∞Â≠óÁªÑÂêà
            /['""]([A-Z0-9]{8,20})['""]/g, // ÂºïÂè∑ÂåÖÂõ¥
        ];

        codePatterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
                const code = match[1] || match[0];

                if (this.isValidCode(code) && !this.isDuplicateCode(code)) {
                    codes.push({
                        code: code,
                        description: this.extractCodeContext(text, code),
                        confidence: this.calculateCodeConfidence(code, text),
                        extractedAt: new Date().toISOString()
                    });
                }
            }
        });

        return codes;
    }

    /**
     * È™åËØÅÂÖëÊç¢Á†ÅÊúâÊïàÊÄß
     */
    isValidCode(code) {
        // ÈïøÂ∫¶Ê£ÄÊü•
        if (code.length < 6 || code.length > 25) return false;

        // ÊéíÈô§Â∏∏ËßÅÂçïËØç
        const excludeWords = ['AND', 'THE', 'FOR', 'WITH', 'HAVE', 'THIS', 'THAT', 'FROM', 'THEY', 'BEEN'];
        if (excludeWords.includes(code)) return false;

        // ÂøÖÈ°ªÂåÖÂê´Ëá≥Â∞ë‰∏Ä‰∏™Êï∞Â≠óÊàñÂ§ßÂÜôÂ≠óÊØç
        const hasNumber = /\d/.test(code);
        const hasLetter = /[A-Z]/.test(code);

        return hasNumber || hasLetter;
    }

    /**
     * Ê£ÄÊü•ÊòØÂê¶‰∏∫ÈáçÂ§çÂÖëÊç¢Á†Å
     */
    isDuplicateCode(code) {
        const storedCodes = this.cacheManager.getStoredCodes();
        return storedCodes.some(stored => stored.code === code);
    }

    /**
     * ÊèêÂèñÂÖëÊç¢Á†Å‰∏ä‰∏ãÊñá
     */
    extractCodeContext(text, code) {
        const beforeText = text.substring(Math.max(0, text.indexOf(code) - 100), text.indexOf(code));
        const afterText = text.substring(text.indexOf(code) + code.length, Math.min(text.length, text.indexOf(code) + code.length + 100));

        return {
            before: beforeText.trim(),
            after: afterText.trim(),
            full: `${beforeText} ${code} ${afterText}`.trim()
        };
    }

    /**
     * ËÆ°ÁÆóÂÖëÊç¢Á†ÅÁΩÆ‰ø°Â∫¶
     */
    calculateCodeConfidence(code, text) {
        let confidence = 0.5; // Âü∫Á°ÄÁΩÆ‰ø°Â∫¶

        // ÈïøÂ∫¶ÈÄÇ‰∏≠Âä†ÂàÜ
        if (code.length >= 8 && code.length <= 16) confidence += 0.2;

        // ÂåÖÂê´Êï∞Â≠óÂä†ÂàÜ
        if (/\d/.test(code)) confidence += 0.1;

        // ‰∏ä‰∏ãÊñáÊúâÂÖ≥ÈîÆËØçÂä†ÂàÜ
        const contextKeywords = ['code', 'gift', 'promo', 'redeem', 'claim', 'reward', 'free'];
        const hasKeywords = contextKeywords.some(keyword =>
            text.toLowerCase().includes(keyword)
        );
        if (hasKeywords) confidence += 0.2;

        // Ê†ºÂºèËßÑËåÉÂä†ÂàÜ
        if (/^[A-Z0-9_-]+$/.test(code)) confidence += 0.1;

        return Math.min(1.0, confidence);
    }

    /**
     * Â§ÑÁêÜÊäìÂèñÂà∞ÁöÑÂÖëÊç¢Á†Å
     */
    async processScrapedCodes(source, codes) {
        if (codes.length === 0) {
            console.log(`No new codes found from ${source}`);
            return;
        }

        console.log(`Found ${codes.length} potential codes from ${source}`);

        // È™åËØÅÂíåËøáÊª§
        const validCodes = codes.filter(codeData =>
            codeData.confidence > 0.6 && this.contentValidator.validateCode(codeData)
        );

        if (validCodes.length === 0) {
            console.log(`No valid codes from ${source} after validation`);
            return;
        }

        // Â≠òÂÇ®Âà∞ÁºìÂ≠ò
        for (const codeData of validCodes) {
            await this.cacheManager.storeCode(codeData);
        }

        // ÈÄöÁü•Êõ¥Êñ∞Á≥ªÁªü
        this.notifyNewCodes(source, validCodes);

        console.log(`Successfully processed ${validCodes.length} codes from ${source}`);
    }

    /**
     * ÈÄöÁü•Êñ∞ÂÖëÊç¢Á†Å
     */
    notifyNewCodes(source, codes) {
        const event = new CustomEvent('newCodesScraped', {
            detail: { source, codes, timestamp: Date.now() }
        });
        document.dispatchEvent(event);

        // Â¶ÇÊûúÊúâÂÖ®Â±ÄÁöÑCMSÁ≥ªÁªüÔºåÈÄöÁü•ÂÆÉ
        if (window.cms) {
            codes.forEach(codeData => {
                window.cms.addNewCode({
                    code: codeData.code,
                    rewards: this.extractRewardsFromContext(codeData.description),
                    description: `Auto-scraped from ${source}`,
                    expires: this.estimateExpiryFromContext(codeData.description),
                    priority: codeData.confidence > 0.8 ? 'high' : 'medium'
                });
            });
        }
    }

    /**
     * ‰ªé‰∏ä‰∏ãÊñáÊèêÂèñÂ•ñÂä±‰ø°ÊÅØ
     */
    extractRewardsFromContext(context) {
        const rewardKeywords = {
            'gem': 'üíé Gems',
            'diamond': 'üíé Diamonds',
            'gold': 'üí∞ Gold',
            'coin': 'üí∞ Coins',
            'ticket': 'üé´ Tickets',
            'potion': 'üß™ Potions',
            'energy': '‚ö° Energy',
            'stamina': 'üí™ Stamina'
        };

        let rewards = 'Various rewards';

        for (const [keyword, reward] of Object.entries(rewardKeywords)) {
            if (context.toLowerCase().includes(keyword)) {
                rewards = reward;
                break;
            }
        }

        return rewards;
    }

    /**
     * ‰ªé‰∏ä‰∏ãÊñá‰º∞ÁÆóËøáÊúüÊó∂Èó¥
     */
    estimateExpiryFromContext(context) {
        const timePatterns = {
            '24 hour': this.getDateFromDays(1),
            '48 hour': this.getDateFromDays(2),
            '3 day': this.getDateFromDays(3),
            'week': this.getDateFromDays(7),
            '2 week': this.getDateFromDays(14),
            'month': this.getDateFromDays(30)
        };

        for (const [pattern, date] of Object.entries(timePatterns)) {
            if (context.toLowerCase().includes(pattern)) {
                return date;
            }
        }

        // ÈªòËÆ§30Â§©ÂêéËøáÊúü
        return this.getDateFromDays(30);
    }

    /**
     * ‰ªéÂ§©Êï∞Ëé∑ÂèñÊó•Êúü
     */
    getDateFromDays(days) {
        const date = new Date();
        date.setDate(date.getDate() + days);
        return date.toISOString().split('T')[0];
    }

    /**
     * ‰ΩøÁî®‰ª£ÁêÜËé∑ÂèñÂÜÖÂÆπ
     */
    async fetchWithProxy(url) {
        // ÊñπÊ°à1Ôºö‰ΩøÁî®CORS‰ª£ÁêÜ
        const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;

        // ÊñπÊ°à2Ôºö‰ΩøÁî®Ëá™Âª∫‰ª£ÁêÜ
        // const proxyUrl = `https://your-proxy-server.com/proxy?url=${encodeURIComponent(url)}`;

        // ÊñπÊ°à3ÔºöÂêéÁ´ØAPI‰ª£ÁêÜ
        // const response = await fetch('/api/proxy', {
        //     method: 'POST',
        //     headers: { 'Content-Type': 'application/json' },
        //     body: JSON.stringify({ url })
        // });

        try {
            const response = await fetch(proxyUrl, {
                method: 'GET',
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    'Accept-Language': 'en-US,en;q=0.5',
                    'Accept-Encoding': 'gzip, deflate',
                    'Connection': 'keep-alive',
                }
            });
            return response;
        } catch (error) {
            console.error('Proxy fetch failed, trying direct:', error);
            return await fetch(url);
        }
    }

    /**
     * Â§ÑÁêÜÊäìÂèñÈîôËØØ
     */
    handleScrapingError(source, error) {
        console.error(`Scraping error for ${source}:`, error);

        // ËÆ∞ÂΩïÈîôËØØ
        this.cacheManager.logError(source, error);

        // Â¶ÇÊûúÈ¢ëÁπÅÂ§±Ë¥•ÔºåÊöÇÊó∂Á¶ÅÁî®ËØ•Êï∞ÊçÆÊ∫ê
        const errorCount = this.cacheManager.getErrorCount(source);
        if (errorCount > 5) {
            console.log(`Temporarily disabling ${source} due to repeated errors`);
            this.sources[source].enabled = false;

            // 1Â∞èÊó∂ÂêéÈáçÊñ∞ÂêØÁî®
            setTimeout(() => {
                this.sources[source].enabled = true;
                this.cacheManager.clearErrors(source);
            }, 3600000);
        }
    }

    /**
     * ËÆæÁΩÆ‰∫ã‰ª∂Â§ÑÁêÜÂô®
     */
    setupEventHandlers() {
        // ÁõëÂê¨ÊâãÂä®Ëß¶ÂèëÊäìÂèñ
        document.addEventListener('triggerScraping', (event) => {
            const source = event.detail.source;
            if (source) {
                this.scrapeSource(source);
            } else {
                this.performScheduledScraping();
            }
        });

        // ÁõëÂê¨ÈÖçÁΩÆÊõ¥Êñ∞
        document.addEventListener('updateScrapingConfig', (event) => {
            const { source, config } = event.detail;
            if (this.sources[source]) {
                this.sources[source] = { ...this.sources[source], ...config };
                this.saveConfig();
            }
        });
    }

    /**
     * Âä†ËΩΩÂ≠òÂÇ®ÁöÑÊï∞ÊçÆ
     */
    loadStoredData() {
        try {
            const stored = localStorage.getItem('scraper_config');
            if (stored) {
                const config = JSON.parse(stored);
                Object.assign(this.sources, config.sources);
            }
        } catch (error) {
            console.error('Failed to load scraper config:', error);
        }
    }

    /**
     * ‰øùÂ≠òÈÖçÁΩÆ
     */
    saveConfig() {
        try {
            const config = { sources: this.sources };
            localStorage.setItem('scraper_config', JSON.stringify(config));
        } catch (error) {
            console.error('Failed to save scraper config:', error);
        }
    }

    /**
     * Ëé∑ÂèñÊäìÂèñÁªüËÆ°
     */
    getScrapingStats() {
        return {
            sources: this.sources,
            stats: this.cacheManager.getStats(),
            lastRun: this.cacheManager.getLastRun(),
            errorCount: this.cacheManager.getTotalErrors()
        };
    }

    /**
     * ÊâãÂä®Ëß¶ÂèëÊäìÂèñ
     */
    async manualScrape(source = null) {
        if (source) {
            await this.scrapeSource(source);
        } else {
            await this.performScheduledScraping();
        }
    }
}

/**
 * ÊäìÂèñÊï∞ÊçÆÁºìÂ≠òÁÆ°ÁêÜÂô®
 */
class ScrapedDataCache {
    constructor() {
        this.cacheKey = 'scraped_data_cache';
        this.errorKey = 'scraping_errors';
        this.statsKey = 'scraping_stats';
    }

    async storeCode(codeData) {
        try {
            const cache = this.getCache();
            cache.codes.push(codeData);

            // ‰øùÊåÅÊúÄËøë1000Êù°ËÆ∞ÂΩï
            if (cache.codes.length > 1000) {
                cache.codes = cache.codes.slice(-1000);
            }

            localStorage.setItem(this.cacheKey, JSON.stringify(cache));
        } catch (error) {
            console.error('Failed to store scraped code:', error);
        }
    }

    getStoredCodes() {
        const cache = this.getCache();
        return cache.codes || [];
    }

    getCache() {
        try {
            const cached = localStorage.getItem(this.cacheKey);
            return cached ? JSON.parse(cached) : { codes: [] };
        } catch (error) {
            console.error('Failed to get cache:', error);
            return { codes: [] };
        }
    }

    logError(source, error) {
        try {
            const errors = this.getErrors();
            errors.push({
                source,
                error: error.message,
                timestamp: new Date().toISOString()
            });

            localStorage.setItem(this.errorKey, JSON.stringify(errors));
        } catch (error) {
            console.error('Failed to log error:', error);
        }
    }

    getErrors() {
        try {
            const errors = localStorage.getItem(this.errorKey);
            return errors ? JSON.parse(errors) : [];
        } catch (error) {
            return [];
        }
    }

    getErrorCount(source) {
        const errors = this.getErrors();
        return errors.filter(e => e.source === source).length;
    }

    clearErrors(source) {
        const errors = this.getErrors().filter(e => e.source !== source);
        localStorage.setItem(this.errorKey, JSON.stringify(errors));
    }

    getStats() {
        try {
            const stats = localStorage.getItem(this.statsKey);
            return stats ? JSON.parse(stats) : {};
        } catch (error) {
            return {};
        }
    }

    getLastRun() {
        const stats = this.getStats();
        return stats.lastRun || null;
    }

    getTotalErrors() {
        return this.getErrors().length;
    }
}

/**
 * ÈÄüÁéáÈôêÂà∂Âô®
 */
class RateLimiter {
    constructor() {
        this.lastRequest = 0;
        this.minInterval = 2000; // ÊúÄÂ∞èËØ∑Ê±ÇÈó¥Èöî2Áßí
    }

    async wait() {
        const now = Date.now();
        const timeSinceLastRequest = now - this.lastRequest;

        if (timeSinceLastRequest < this.minInterval) {
            const waitTime = this.minInterval - timeSinceLastRequest;
            await new Promise(resolve => setTimeout(resolve, waitTime));
        }

        this.lastRequest = Date.now();
    }
}

/**
 * ÂÜÖÂÆπÈ™åËØÅÂô®
 */
class ContentValidator {
    validateCode(codeData) {
        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊúâÊïàÊ†ºÂºè
        if (!codeData.code || codeData.code.length < 6) return false;

        // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´‰∏çÂΩìÂÜÖÂÆπ
        const blacklist = ['spam', 'abuse', 'inappropriate'];
        const hasBlacklist = blacklist.some(word =>
            codeData.description.toLowerCase().includes(word)
        );
        if (hasBlacklist) return false;

        // Ê£ÄÊü•ÁΩÆ‰ø°Â∫¶
        if (codeData.confidence < 0.6) return false;

        return true;
    }
}

// ÂØºÂá∫ÊäìÂèñÂô®ÂÆû‰æã
window.gameContentScraper = new GameContentScraper();
window.GameContentScraper = GameContentScraper;

// ÂÖ®Â±ÄËß¶ÂèëÊäìÂèñÂáΩÊï∞
window.triggerScraping = (source = null) => {
    window.gameContentScraper.manualScrape(source);
};

console.log('Game Content Scraper loaded successfully');